########################################
#   data_fig07_08_bcf.py
#
#   Description. Script used to generate data for Figs. 7 and 8 of the paper
#   concerning BCF curves.
#
#   Author. @victorcroisfelt
#
#   Date. December 27, 2021
#
#   This code is part of the code package used to generate the numeric results
#   of the paper:
#
#   Croisfelt, V., Abrão, T., and Marinello, J. C., “User-Centric Perspective in
#   Random Access Cell-Free Aided by Spatial Separability”, arXiv e-prints, 2021.
#
#   Available on:
#
#                   https://arxiv.org/abs/2107.10294
#
#   Comment. You need to run:
#
#       - plot_fig07c_anaa_lower.py
#       - plot_fig07d_anaa_practical.py
#       - plot_fig08_tcp.py
#
#   to actually plot the figure using the data generated by this script.
########################################
import numpy as np

import time

from settings_fig07_08 import *

########################################
# Simulation
########################################
print("--------------------------------------------------")
print('Data Figs 07 & 08: BCF -- ANAA and TCP')
print("--------------------------------------------------\n")

# Store total time 
total_time = time.time()

# Prepare to save simulation results
finalWaitingTimes = np.zeros((len(K0values), maxAttempts))
avg_activePilots = np.zeros((len(K0values)))


#####


# BCF: all APs serve all pilots
Pcal = np.arange(L)

# Store enumeration of L
enumerationL = Pcal


# Go through all different number of inactive UEs
for kk, K0 in enumerate(K0values):

    # Storing time
    timer_start = time.time()

    # Print current data point
    print(f"\tinactive UEs: {kk}/{len(K0values)-1}")

    # Generate the number of UEs that wish to access the network (for the first
    # time) in each of the RA blocks
    newUEs = np.random.binomial(K0, pA, size=numRAblocks)

    # Initiate memories to store set of UEs that have failed to access the
    # network
    waitingTime = [] # Contains number of access attempts
    waitingBetas = [] # Average channel gains of UEs

    # Go through all RA blocks
    for r in range(numRAblocks):


        #####
        # Generating UEs
        #####


        # Generate UEs locations
        newUElocations = squareLength * (np.random.rand(newUEs[r]) + 1j*np.random.rand(newUEs[r]))

        # Compute UEs distances to each AP
        newUEdistances = abs(APpositions - newUElocations[:, None])

        # Compute average channel gains according to Eq. (1)
        newBetas = 10**((94.0 - 30.5 - 36.7 * np.log10(np.sqrt(newUEdistances**2 + 10**2)))/10)


        #####
        # Preparing for RA Attempt
        #####


        # Combine the new UEs with the ones that have made previous access
        # attempts
        if len(np.array(waitingBetas)) == 0:
            betas = newBetas
        else:
            betas = np.concatenate((newBetas, np.array(waitingBetas)))

        # Compute number of UEs that will send pilots
        numAccessingUEs = betas.shape[0]

        # Randomize if each of the UEs that retransmit pilots should really send
        # a pilot in this RA block. One means retransmit and zero means do not
        # retransmit in this block
        shouldWaitingUsersRetransmit = np.random.binomial(1, tryAgainProb, size=len(waitingTime)).astype(int)

        # Create a list of the UEs that will send pilots (all new UEs transmit
        # pilots)
        accessAttempt = np.concatenate((np.ones(newUEs[r], dtype=np.uint), shouldWaitingUsersRetransmit)).astype(int)

        # Randomize which pilot each UE chose
        pilotSelections = accessAttempt*np.random.randint(1, taup+1, size=numAccessingUEs).astype(int)
        pilotSelections += -1

        # Count the number of pilots that each of the UEs will have transmitted,
        # after this block
        accessAttempts = np.concatenate((np.ones(newUEs[r], dtype=np.uint), waitingTime + shouldWaitingUsersRetransmit)).astype(int)

        # Check existence of transmission
        if len(accessAttempts) != 0:

            # Prepare a list of UEs that succeed in the random access
            successfulAttempt = np.zeros(numAccessingUEs, dtype=bool)

            # Get list of active pilots
            activePilots = np.unique(pilotSelections)

            # Update number of active pilots
            avg_activePilots[kk] += len(activePilots)
            
            # Go through all active RA pilots
            for t in activePilots:

                # Extract UEs that transmit pilot t
                UEindices = np.where(pilotSelections == t)[0]

                # Obtain collision size
                collisionSize = len(UEindices)

                # Single transmission
                if collisionSize == 1:

                    # Automatic succesful attempt
                    successfulAttempt[UEindices[0]] = True
                    finalWaitingTimes[kk, int(accessAttempts[UEindices[0]] - 1)] += 1

                # Collision case
                elif collisionSize > 1:

                    # Prepare to save a list of all the natural sets of nearby 
                    # APs from colliding UEs
                    checkCcal = []

                    # Go through all colliding UEs
                    for k in range(collisionSize):

                        # Obtain natural set of nearby APs of UE k (Definition 1)
                        checkCcal_k = enumerationL[ql * betas[UEindices[k], :] > sigma2]

                        if len(checkCcal_k) == 0:
                            checkCcal_k = np.array([np.argmax(ql * betas[UEindices[k], :])])

                        # Store natural set
                        checkCcal.append(set(checkCcal_k))

                    # Go again through all colliding UEs
                    for k in range(collisionSize):

                        # Extract current natural set of nearby APs of UE k
                        checkCcal_k = checkCcal[k]

                        # Compute intersection with Pcal
                        int_Pcal_checkCcal_k = set.intersection(set(Pcal), checkCcal_k)

                        # Spatial Separability (Definition 3): the following ifs
                        # are performed according to the defition of spatial
                        # separability

                        # Check first condition
                        if len(int_Pcal_checkCcal_k) > 0:

                            # Obtain union of natural sets excluding the one from
                            # UE k
                            checkCcal__k = set.union(*(checkCcal[:k] + checkCcal[k+1:]))

                            # Compute intersection with Pcal
                            int_Pcal_checkCcal__k = set.intersection(set(Pcal), checkCcal__k)

                            # Check second condition
                            if len(int_Pcal_checkCcal_k - int_Pcal_checkCcal__k) != 0:

                                # Succesful attempt: UE k is spatially separable
                                successfulAttempt[UEindices[k]] = True
                                finalWaitingTimes[kk, int(accessAttempts[UEindices[k]] - 1)] += 1

            # Determine which of the UEs have failed too many times with their 
            # access attempts and will give up
            giveUp = (accessAttempts[successfulAttempt == 0] == maxAttempts)
            finalWaitingTimes[kk, -1] += sum(giveUp)

            # Keep the important parameters for all the UEs that failed to
            # access the network and did not give up
            mask_remaining = np.logical_and((successfulAttempt == 0), (accessAttempts < maxAttempts))

            waitingTime = accessAttempts[mask_remaining]
            waitingBetas = betas[mask_remaining]

    print("\t[|U|] elapsed " + str(np.round(time.time() - timer_start, 4)) + " seconds.\n")

# Compute average number of active pilots
avg_activePilots *= 1/numRAblocks

# Compute ANAA
anaa = (np.arange(1, maxAttempts+1)[np.newaxis, :] * (finalWaitingTimes/np.sum(finalWaitingTimes, axis=-1)[:, np.newaxis])).sum(axis=-1)

# Compute TCP in Eq. (43)
tcp = anaa * ql * avg_activePilots * L

print("total simulation time was " + str(np.round(time.time() - total_time, 4)) + " seconds.\n")

print("wait for data saving...\n")

# Save simulation results
np.savez("data/fig07_08_bcf.npz",
    K0values=K0values,
    anaa=anaa,
    tcp=tcp
)

print("the data has been saved in the /data folder.\n")

print("------------------- all done :) ------------------")
