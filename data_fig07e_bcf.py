########################################
#   data_fig07_08_bcf.py
#
#   Description. Script used to generate data for Figs. 7 and 8 of the paper
#   concerning BCF curves.
#
#   Author. @victorcroisfelt
#
#   Date. December 27, 2021
#
#   This code is part of the code package used to generate the numeric results
#   of the paper:
#
#   Croisfelt, V., Abrão, T., and Marinello, J. C., “User-Centric Perspective in
#   Random Access Cell-Free Aided by Spatial Separability”, arXiv e-prints, 2021.
#
#   Available on:
#
#                   https://arxiv.org/abs/2107.10294
#
#   Comment. You need to run:
#
#       - plot_fig07c_anaa_lower.py
#       - plot_fig07d_anaa_practical.py
#       - plot_fig08_tcp.py
#
#   to actually plot the figure using the data generated by this script.
########################################
import numpy as np

import time

########################################
# System parameters
########################################

# UL transmit power
p = 100

# Define noise power
sigma2 = 1

# Number of RA pilot signals
taup = 5

# Number of inactive users
K0 = 10000

########################################
# Geometry
########################################

# Define square length
squareLength = 400

########################################
# SUCRe parameters
########################################

# Probability of access
pA = 0.001

# Maximum number of attempts to send RA pilots before a UE gives up
maxAttempts = 10

# Probability of retransmitting an RA pilot in each follow RA block, when the
# first transmission was failed
tryAgainProb = 0.5

########################################
# Simulation parameters
########################################

# Set the number of RA blocks
numRAblocks = 10000

# Range of number of APs
L_range = np.array([1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144])

# Get maximum of range
L_max = L_range.max()

########################################
# Simulation
########################################
print('--------------------------------------------------')
print('Data Fig. 07e: BCF -- ANAA')
print('--------------------------------------------------')

# Store total time 
total_time = time.time()

# Prepare to save final waiting times
finalWaitingTimes = np.zeros((L_range.size, maxAttempts))


#####


# Generate the number of UEs that wish to access the network (for the first
# time) in each of the RA blocks
newUEs = np.random.binomial(K0, pA, size=numRAblocks)


# Go through all different number of APs
for ll, L in enumerate(L_range):

    # Storing time
    timer_kk = time.time()

    # Print current data point
    print(f"\tL: {ll}/{len(L_range)-1}")

    # Compute DL transmit power per AP
    ql = 200/L

    # Create square grid of APs
    APperdim = int(np.sqrt(L))
    APpositions = np.linspace(squareLength/APperdim, squareLength, APperdim) - squareLength/APperdim/2
    APpositions = APpositions + 1j*APpositions[:, None]
    APpositions = APpositions.reshape(L)

    # BCF: all APs serve all pilots
    Pcal = np.arange(L)

    # Store enumeration of L
    enumerationL = Pcal

    # Initiate memories to store set of UEs that have failed to access the
    # network
    waitingTime = [] # Contains number of access attempts
    waitingBetas = [] # Average channel gains of UEs


    # Go through all RA blocks
    for r in range(numRAblocks):


        #####
        # Generating UEs
        #####


        # Generate UEs locations
        newUElocations = squareLength * (np.random.rand(newUEs[r]) + 1j*np.random.rand(newUEs[r]))

        # Compute UEs distances to each AP
        newUEdistances = abs(APpositions - newUElocations[:, None])

        # Compute average channel gains according to Eq. (1)
        newBetas = 10**((94.0 - 30.5 - 36.7 * np.log10(np.sqrt(newUEdistances**2 + 10**2)))/10)


        #####
        # Preparing for RA Attempt
        #####


        # Combine the new UEs with the ones that have made previous access
        # attempts
        if len(np.array(waitingBetas)) == 0:
            betas = newBetas
        else:
            betas = np.concatenate((newBetas, np.array(waitingBetas)))

        # Compute number of UEs that will send pilots
        numAccessingUEs = betas.shape[0]

        # Randomize if each of the UEs that retransmit pilots should really send
        # a pilot in this RA block. One means retransmit and zero means do not
        # retransmit in this block
        shouldWaitingUsersRetransmit = np.random.binomial(1, tryAgainProb, size=len(waitingTime)).astype(int)

        # Create a list of the UEs that will send pilots (all new UEs transmit
        # pilots)
        accessAttempt = np.concatenate((np.ones(newUEs[r], dtype=np.uint), shouldWaitingUsersRetransmit)).astype(int)

        # Randomize which pilot each UE chose
        pilotSelections = accessAttempt*np.random.randint(1, taup+1, size=numAccessingUEs).astype(int)
        pilotSelections += -1

        # Count the number of pilots that each of the UEs will have transmitted,
        # after this block
        accessAttempts = np.concatenate((np.ones(newUEs[r], dtype=np.uint), waitingTime + shouldWaitingUsersRetransmit)).astype(int)

        # Check existence of transmission
        if len(accessAttempts) != 0:

            # Prepare a list of UEs that succeed in the random access
            successfulAttempt = np.zeros(numAccessingUEs, dtype=bool)

            # Get list of active pilots
            activePilots = np.unique(pilotSelections)


            # Go through all active RA pilots
            for t in activePilots:

                # Extract UEs that transmit pilot t
                UEindices = np.where(pilotSelections == t)[0]

                # Obtain collision size
                collisionSize = len(UEindices)

                # Single transmission
                if collisionSize == 1:

                    # Automatic succesful attempt
                    successfulAttempt[UEindices[0]] = True
                    finalWaitingTimes[ll, int(accessAttempts[UEindices[0]] - 1)] += 1

                # Collision case
                elif collisionSize > 1:

                    # Prepare to save a list of all the natural sets of nearby 
                    # APs from colliding UEs
                    checkCcal = []

                    # Go through all colliding UEs
                    for k in range(collisionSize):

                        # Obtain natural set of nearby APs of UE k (Definition 1)
                        checkCcal_k = enumerationL[ql * betas[UEindices[k], :] > sigma2]

                        if len(checkCcal_k) == 0:
                            checkCcal_k = np.array([np.argmax(ql * betas[UEindices[k], :])])

                        # Store natural set
                        checkCcal.append(set(checkCcal_k))

                    # Go again through all colliding UEs
                    for k in range(collisionSize):

                        # Extract current natural set of nearby APs of UE k
                        checkCcal_k = checkCcal[k]

                        # Compute intersection with Pcal
                        int_Pcal_checkCcal_k = set.intersection(set(Pcal), checkCcal_k)

                        # Spatial Separability (Definition 3): the following ifs
                        # are performed according to the defition of spatial
                        # separability

                        # Check first condition
                        if len(int_Pcal_checkCcal_k) > 0:

                            # Obtain union of natural sets excluding the one from
                            # UE k
                            checkCcal__k = set.union(*(checkCcal[:k] + checkCcal[k+1:]))

                            # Compute intersection with Pcal
                            int_Pcal_checkCcal__k = set.intersection(set(Pcal), checkCcal__k)

                            # Check second condition
                            if len(int_Pcal_checkCcal_k - int_Pcal_checkCcal__k) != 0:

                                # Succesful attempt: UE k is spatially separable
                                successfulAttempt[UEindices[k]] = True
                                finalWaitingTimes[ll, int(accessAttempts[UEindices[k]] - 1)] += 1

            # Determine which of the UEs have failed too many times with their 
            # access attempts and will give up
            giveUp = (accessAttempts[successfulAttempt == 0] == maxAttempts)
            finalWaitingTimes[ll, -1] += sum(giveUp)

            # Keep the important parameters for all the UEs that failed to
            # access the network and did not give up
            mask_remaining = np.logical_and((successfulAttempt == 0), (accessAttempts < maxAttempts))

            waitingTime = accessAttempts[mask_remaining]
            waitingBetas = betas[mask_remaining]

    print("\t[L] elapsed " + str(np.round(time.time() - timer_kk, 4)) + " seconds.\n")

# Prepare to save ANAA
anaa = np.zeros((L_range.size))

# Go through all different number of APs
for ll, L in enumerate(L_range):

    # Compute ANAA
    anaa[ll] = (np.arange(1, maxAttempts+1) * (finalWaitingTimes[ll]/np.sum(finalWaitingTimes[ll]))).sum()

print("total simulation time was " + str(np.round(time.time() - total_time, 4)) + " seconds.\n")

print("wait for data saving...\n")

# Save simulation results
np.savez('data/fig07e_bcf.npz',
    L_range=L_range,
    anaa=anaa
)

print("your data has been saved in the /data folder.\n")

print("------------------- all done :) ------------------")
