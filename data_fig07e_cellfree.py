########################################
#   data_fig07e.py
#
#   Description. Script used to generate data for Figs. 7 (e) the paper.
#   You should choose the estimator.
#
#   Author. @victorcroisfelt
#
#   Date. December 29, 2021
#
#   This code is part of the code package used to generate the numeric results
#   of the paper:
#
#   Croisfelt, V., Abrão, T., and Marinello, J. C., “User-Centric Perspective in
#   Random Access Cell-Free Aided by Spatial Separability”, arXiv e-prints, 2021.
#
#   Available on:
#
#                   https://arxiv.org/abs/2107.10294
#
#   Comment. You need to run:
#
#       - plot_fig07e_N_L.py
#
#   to actually plot the figure using the data generated by this script.
########################################
import numpy as np

import time

########################################
# System parameters
########################################

# UL transmit power
p = 100

# Define noise power
sigma2 = 1

# Number of RA pilot signals
taup = 5

# Number of inactive users
K0 = 10000

########################################
# SELECTION
########################################

# Choose estimator
estimator = 'est1'
#estimator = 'est2'
#estimator = 'est3'

########################################
# Lookup tables
########################################

# Get lookup tables from the according files.
# You should run the codes:
#
# - lookup_fig07e_practical.py
#
# to get the required files.

load = np.load("lookup/lookup_fig07e_practical.npz", allow_pickle=True)
practical_lookup = load["practical"]
practical_lookup = practical_lookup.item()

########################################
# Geometry
########################################

# Define square length
squareLength = 400

########################################
# SUCRe parameters
########################################

# Probability of access
pA = 0.001

# Maximum number of attempts to send RA pilots before a UE gives up
maxAttempts = 10

# Probability of retransmitting an RA pilot in each follow RA block, when the
# first transmission was failed
tryAgainProb = 0.5

########################################
# Simulation parameters
########################################

# Set the number of RA blocks
numRAblocks = 10000

# Range of number of APs
L_range = np.array([1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144])

# Range of number of antennas per AP
N_range = np.array([1, 2, 4, 8])

# Get maximum of ranges
L_max = L_range.max()
N_max = N_range.max()

########################################
# Simulation
########################################
print('--------------------------------------------------')
print('Data Fig. 07e: CFSUCRe -- ANAA')
print('\t Estimator: ' + estimator)
print('--------------------------------------------------')

# Store total time 
total_time = time.time()

# Prepare to save final waiting times
finalWaitingTimes = np.zeros((L_range.size, N_range.size, maxAttempts))


#####


# Generate noise realizations at APs
n_ = np.sqrt(sigma2/2)*(np.random.randn(N_max, L_max, taup, numRAblocks) + 1j*np.random.randn(N_max, L_max, taup, numRAblocks))

# Generate the number of UEs that wish to access the network (for the first
# time) in each of the RA blocks
newUEs = np.random.binomial(K0, pA, size=numRAblocks)


# Go through all different number of APs
for ll, L in enumerate(L_range):

    # Storing time
    timer_kk = time.time()

    # Print current data point
    print(f"\tL: {ll}/{len(L_range)-1}")

    # Compute DL transmit power per AP
    ql = 200/L

    # Create square grid of APs
    APperdim = int(np.sqrt(L))
    APpositions = np.linspace(squareLength/APperdim, squareLength, APperdim) - squareLength/APperdim/2
    APpositions = APpositions + 1j*APpositions[:, None]
    APpositions = APpositions.reshape(L)

    # Store enumeration of L
    enumerationL = np.arange(L)


    # Go through all different number of antennas per APs
    for nn, N in enumerate(N_range):

        # Print current data point
        print(f"\t\tN: {nn}/{len(N_range)-1}")

        # Extract current Lmax
        Lmax = practical_lookup.get((L, N))[0]

        # Extract current delta 
        if estimator == 'est3':
            delta = practical_lookup.get((L, N))[1]
        
        # Initiate memories to store set of UEs that have failed to access the
        # network
        waitingTime = [] # Contains number of access attempts
        waitingBetas = [] # Average channel gains of UEs


        # Go through all RA blocks
        for r in range(numRAblocks):


            #####
            # Generating UEs
            #####


            # Generate UEs locations
            newUElocations = squareLength*(np.random.rand(newUEs[r]) + 1j*np.random.rand(newUEs[r]))

            # Compute UEs distances to each AP
            newUEdistances = abs(APpositions - newUElocations[:, None])

            # Compute average channel gains according to Eq. (1)
            newBetas = 10**((94.0 - 30.5 - 36.7 * np.log10(np.sqrt(newUEdistances**2 + 10**2)))/10)


            #####
            # Preparing for RA Attempt
            #####


            # Combine the new UEs with the ones that have made previous access
            # attempts
            if len(np.array(waitingBetas)) == 0:
                betas = newBetas
            else:
                betas = np.concatenate((newBetas, np.array(waitingBetas)))

            # Compute number of UEs that will send pilots
            numberOfAccessingUEs = betas.shape[0]

            # Randomize if each of the UEs that retransmit pilots should really send
            # a pilot in this RA block. One means retransmit and zero means do not
            # retransmit in this block
            shouldWaitingUsersRetransmit = np.random.binomial(1, tryAgainProb, size=len(waitingTime)).astype(int)

            # Create a list of the UEs that will send pilots (all new UEs transmit
            # pilots)
            accessAttempt = np.concatenate((np.ones(newUEs[r], dtype=np.uint), shouldWaitingUsersRetransmit)).astype(int)

            # Randomize which pilot each UE chose
            pilotSelections = accessAttempt*np.random.randint(1, taup+1, size=numberOfAccessingUEs).astype(int)
            pilotSelections += -1

            # Count the number of pilots that each of the UEs will have transmitted,
            # after this block
            accessAttempts = np.concatenate((np.ones(newUEs[r], dtype=np.uint), waitingTime + shouldWaitingUsersRetransmit)).astype(int)

            # Check existence of transmission
            if len(accessAttempts) != 0:

                # Generate channel matrix at each AP equipped with N antennas
                G = np.sqrt(betas[None, :, :]/2)*(np.random.randn(N, numberOfAccessingUEs, L) + 1j*np.random.randn(N, numberOfAccessingUEs, L))

                # Prepare a list of UEs that succeed in the random access
                successfulAttempt = np.zeros(numberOfAccessingUEs, dtype=bool)

                # Get list of active pilots
                activePilots = np.unique(pilotSelections)


                # Go through all active RA pilots
                for t in activePilots:

                    # Extract UEs that transmit pilot t
                    UEindices = np.where(pilotSelections == t)[0]

                    # Obtain collision size
                    collisionSize = len(UEindices)

                    # Compute received signal according to Eq. (4)
                    Yt_ = np.sqrt(p * taup)*(G[:, UEindices, :]).sum(axis=1) + n_[:N, :L, t, r]

                    # Store l2-norms of Yt
                    Yt_norms = np.linalg.norm(Yt_, axis=0)

                    # Obtain pilot activity matrix according to Eq. (8)
                    Atilde = (1/N) * Yt_norms**2
                    Atilde[Atilde < sigma2] = 0.0

                    # Obtain set of pilot-serving APs (Definition 2)
                    Pcal = np.argsort(Atilde)[-Lmax:]
                    Pcal = np.delete(Pcal, Atilde[Pcal] == 0)


                    #####
                    # SUCRe: step 2
                    #####


                    # Check estimator
                    if estimator == 'est3':

                        # Denominator according to Eq. (34) and (35)
                        den = np.sqrt(N *  np.maximum(Atilde - sigma2, np.zeros((Atilde.shape))).sum())

                        # Compute precoded DL signal according to Eq. (35)
                        Vt = np.sqrt(ql) * (Yt_[:, Pcal] / den)

                    else:

                        # Compute precoded DL signal according to Eq. (10)
                        Vt = np.sqrt(ql) * (Yt_[:, Pcal] / Yt_norms[Pcal])


                    #####
                    # SUCRe: step 3
                    #####


                    # Prepare a list of UEs that decide to retransmit pilot t
                    retransmit = np.zeros((collisionSize), dtype=bool)

                    # Prepare to save a list of all the natural sets of nearby APs 
                    # from colliding UEs
                    checkCcal = []

                    # Go through all colliding UEs
                    for k in range(collisionSize):

                        # Compute received DL signal at UE k according to Eq. (12)
                        noise = np.sqrt(sigma2/2)*(np.random.randn() + 1j*np.random.randn())
                        z_k = np.sqrt(taup) * (G[:, UEindices[k], Pcal].conj() * Vt).sum() + noise

                        # Obtain natural set of nearby APs of UE k (Definition 1)
                        checkCcal_k = enumerationL[ql*betas[UEindices[k], :] > sigma2]

                        if len(checkCcal_k) == 0:
                            checkCcal_k = np.array([np.argmax(ql * betas[UEindices[k], :])])

                        # Store checkCcal_k
                        checkCcal.append(set(checkCcal_k))


                        #####
                        # Estimation
                        #####

                        # Compute unchanged constant
                        if estimator == 'est3':

                            # Compute new constant according to Eq. (38)
                            cte = delta * (z_k.real - sigma2)/np.sqrt(N)

                        else:

                            cte = z_k.real/np.sqrt(N)

                        # Define aux variable
                        aux = int(checkCcal_k.size)

                        while aux > 0:

                            # Obtain current Ccal_k
                            current_Ccal_k = checkCcal_k[-aux:]


                            #####
                            # Estimation
                            #####


                            # Compute new numerator
                            num = np.sqrt(ql * p) * taup * betas[UEindices[k], current_Ccal_k]

                            if estimator == 'est1':

                                # Compute estimate according to Eq. (28)
                                alphahat = ((num.sum()/cte)**2) - sigma2

                            elif estimator == 'est2':

                                num23 = num**(2/3)
                                cte2 = (num23.sum()/cte)**2

                                # Compute estimate according to Eq. (32)
                                alphahat = (cte2 * num23 - sigma2).sum()

                            elif estimator == 'est3':

                                # Compute estimate according to Eq. (40)
                                alphahat = (num.sum() / cte)**2

                            # Compute own total UL signal power in Eq. (15)
                            gamma = p * taup * betas[UEindices[k], current_Ccal_k].sum()

                            # Avoiding underestimation
                            if alphahat < gamma:
                                alphahat = gamma

                            #####
                            # Decision
                            #####

                            # Evaluate decision
                            if gamma > alphahat/2:
                                retransmit[k] = 1
                                break

                            # Update aux variable
                            aux -= 1


                    #####
                    # Evaluate succesful attempts (!!!)
                    #####


                    # Single transmission
                    if sum(retransmit) == 1:
                        successfulAttempt[UEindices[retransmit]] = True
                        finalWaitingTimes[ll, nn, int(accessAttempts[UEindices[retransmit]] - 1)] += 1

                    # Collision case
                    elif sum(retransmit) > 1:

                        # Go through all colliding UEs
                        for k in range(collisionSize):

                            # Extract current natural set of nearby APs of UE k
                            checkCcal_k = checkCcal[k]

                            # Compute intersection with Pcal
                            int_Pcal_checkCcal_k = set.intersection(set(Pcal), checkCcal_k)

                            # Spatial Separability (Definition 3): the following ifs
                            # are performed according to the defition of spatial
                            # separability

                            # Check first condition
                            if len(int_Pcal_checkCcal_k) > 0:

                                # Obtain union of natural sets excluding the one from
                                # UE k
                                checkCcal__k = set.union(*(checkCcal[:k] + checkCcal[k+1:]))

                                # Compute intersection with Pcal
                                int_Pcal_checkCcal__k = set.intersection(set(Pcal), checkCcal__k)

                                # Check second condition
                                if len(int_Pcal_checkCcal_k - int_Pcal_checkCcal__k) != 0:

                                    # Succesful attempt: UE k is spatially separable
                                    successfulAttempt[UEindices[k]] = True
                                    finalWaitingTimes[ll, nn, int(accessAttempts[UEindices[k]] - 1)] += 1

                # Determine which of the UEs have failed too many times with their 
                # access attempts and will give up
                giveUp = (accessAttempts[successfulAttempt == 0] == maxAttempts)
                finalWaitingTimes[ll, nn, -1] += sum(giveUp)

                # Keep the important parameters for all the UEs that failed to
                # access the network and did not give up
                mask_remaining = np.logical_and((successfulAttempt == 0), (accessAttempts < maxAttempts))

                waitingTime = accessAttempts[mask_remaining]
                waitingBetas = betas[mask_remaining]

    print("\t[L] elapsed " + str(np.round(time.time() - timer_kk, 4)) + " seconds.\n")

# Prepare to save ANAA
anaa = np.zeros((L_range.size, N_range.size))

# Go through all different number of APs
for ll, L in enumerate(L_range):

    # Go through all different number of antennas per APs
    for nn, N in enumerate(N_range):

        # Compute ANAA
        anaa[ll, nn] = (np.arange(1, maxAttempts+1) * (finalWaitingTimes[ll, nn]/np.sum(finalWaitingTimes[ll, nn]))).sum()

print("total simulation time was " + str(np.round(time.time() - total_time, 4)) + " seconds.\n")

print("wait for data saving...\n")

# Save simulation results
np.savez('data/fig07e_cellfree_' + estimator + '.npz',
    L_range=L_range,
    N_range=N_range,
    anaa=anaa
)

print("your data has been saved in the /data folder.\n")

print("------------------- all done :) ------------------")

